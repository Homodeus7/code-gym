/**
 * DAY 6: Сортировка и поиск
 * Уровень: Средний
 */

/**
 * Задача 1: Бинарный поиск
 *
 * Дан отсортированный массив nums и значение target.
 * Если target есть в массиве, верните его индекс.
 * Если нет, верните -1.
 * Алгоритм должен иметь O(log n) сложность.
 *
 * Примеры:
 * search([-1, 0, 3, 5, 9, 12], 9) → 4
 * search([-1, 0, 3, 5, 9, 12], 2) → -1
 * search([5], 5) → 0
 *
 * Ограничения:
 * - 1 <= nums.length <= 10^4
 * - -10^4 < nums[i], target < 10^4
 * - Все элементы nums уникальны
 * - nums отсортирован по возрастанию
 */
function search(nums: number[], target: number): number {
  // Ваше решение здесь
  return 0;
}

/**
 * Задача 2: Поиск позиции для вставки
 *
 * Дан отсортированный массив и значение target.
 * Найдите индекс, куда нужно вставить target, чтобы сохранить порядок.
 * Если target уже есть, верните индекс его позиции.
 *
 * Примеры:
 * searchInsert([1, 3, 5, 6], 5) → 2
 * searchInsert([1, 3, 5, 6], 2) → 1
 * searchInsert([1, 3, 5, 6], 7) → 4
 * searchInsert([1, 3, 5, 6], 0) → 0
 *
 * Ограничения:
 * - 1 <= nums.length <= 10^4
 * - -10^4 <= nums[i] <= 10^4
 * - nums отсортирован по возрастанию
 * - -10^4 <= target <= 10^4
 *
 * Подсказка: Модификация бинарного поиска
 */
function searchInsert(nums: number[], target: number): number {
  // Ваше решение здесь
  return 0;
}

/**
 * Задача 3: Пересечение двух массивов
 *
 * Даны два массива nums1 и nums2.
 * Верните массив их пересечения (общие элементы).
 * Каждый элемент должен входить столько раз, сколько он встречается в обоих массивах.
 * Результат может быть в любом порядке.
 *
 * Примеры:
 * intersect([1, 2, 2, 1], [2, 2]) → [2, 2]
 * intersect([4, 9, 5], [9, 4, 9, 8, 4]) → [4, 9] или [9, 4]
 *
 * Ограничения:
 * - 1 <= nums1.length, nums2.length <= 1000
 * - 0 <= nums1[i], nums2[i] <= 1000
 *
 * Follow-up:
 * - Что если массивы отсортированы?
 * - Что если nums1 намного меньше nums2?
 */
function intersect(nums1: number[], nums2: number[]): number[] {
  // Ваше решение здесь
  return [];
}

/**
 * Задача 4: Отсортировать массив по частоте
 *
 * Дан массив чисел nums.
 * Отсортируйте массив по частоте появления элементов:
 * - Более частые элементы идут первыми
 * - Если частота одинакова, меньшее число идет первым
 *
 * Примеры:
 * frequencySort([1, 1, 2, 2, 2, 3]) → [2, 2, 2, 1, 1, 3]
 * frequencySort([2, 3, 1, 3, 2]) → [1, 3, 3, 2, 2] или [2, 2, 3, 3, 1]
 * frequencySort([-1, 1, -6, 4, 5, -6, 1, 4, 1]) → [1, 1, 1, 4, 4, -6, -6, 5, -1]
 *
 * Ограничения:
 * - 1 <= nums.length <= 100
 * - -100 <= nums[i] <= 100
 */
function frequencySort(nums: number[]): number[] {
  // Ваше решение здесь
  return [];
}

// ========================================
// Тесты (раскомментируйте для проверки)
// ========================================

/*
console.log("=== Задача 1: Бинарный поиск ===");
console.log(search([-1, 0, 3, 5, 9, 12], 9)); // 4
console.log(search([-1, 0, 3, 5, 9, 12], 2)); // -1

console.log("\n=== Задача 2: Позиция для вставки ===");
console.log(searchInsert([1, 3, 5, 6], 5)); // 2
console.log(searchInsert([1, 3, 5, 6], 2)); // 1
console.log(searchInsert([1, 3, 5, 6], 7)); // 4

console.log("\n=== Задача 3: Пересечение массивов ===");
console.log(intersect([1, 2, 2, 1], [2, 2])); // [2, 2]
console.log(intersect([4, 9, 5], [9, 4, 9, 8, 4])); // [4, 9] или [9, 4]

console.log("\n=== Задача 4: Сортировка по частоте ===");
console.log(frequencySort([1, 1, 2, 2, 2, 3])); // [2, 2, 2, 1, 1, 3]
console.log(frequencySort([-1, 1, -6, 4, 5, -6, 1, 4, 1])); // [1, 1, 1, 4, 4, -6, -6, 5, -1]
*/
